package com.tz.classdemo;

/**
 * Created by Administrator on 2017/2/4 0004.
 */
public class StaticDemo {

//    类成员，只能通过类访问
//    实例成员只能通过实例访问
        //对象其实可以访问类成员，但是底层依然是使用的类名访问

    //static方法只能调用static成员  //因为实例成员是实例的
    //static加载优先于实例

    //static成员是在JVM的CLASSLOADER加载类的时候初始化的，而非static的成员是在创建对象，即new 操作的时候才初始化的；类加载的时候初始化static的成员，此时static 已经分配内存空间，所以可以访问；非static的成员还没有通过new创建对象而进行初始化，所以必然不可以访问。



   // 构造方法的定义 是与类的名称相同；如果子类能够继承父类的构造方法；那么在子类的构造方法中就有不同于子类名称的构造法；
        //    #这与构造方法的定义不符；所以子类是不能继承父类的构造方法的；

    //java判断方法  是依据方法签名

    //1.子类方法的名称、参数签名和返回类型必须与父类方法的名称、参数签名和返回类型一致。
    //Java编译器首先判断Sub类的method()方法与Base类的method()方法的参数签名，由于两者一致，因此Java编译器认为Sub类的method()方法试图覆盖父类的方法，既然如此，Sub类的method()方法就必须和被覆盖的方法具有相同的返回类型。


    //（4）方法覆盖只存在于子类和父类（包括直接父类和间接父类）之间。在同一个类中方法只能被重载，不能被覆盖。

    //（5）父类的静态方法不能被子类覆盖为非静态方法。 //因为都不是一个级别 调用方式都不一样

    //子类可以定义与父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。在编译时，子类定义的静态方法也必须满足与方法覆盖类似的约束：方法的参数签名一致，返回类型一致，不能缩小父类方法的访问权限，不能抛出更多的异常。

    //父类的非静态方法不能被子类覆盖为静态方法

//    方法覆盖的条件
//    1.实例方法签名必须相同.(方法签名=方法名+形参列表)
//    2.子类方法的返回值是和父类方法的返回值相同或者是其子类
//    3.子类声明抛出的异常类型和父类方法声明抛出的异常类型相同或者是其子类
//    4.子类方法的访问权限比父类访问权限更大或相同

//    方法重载"
//    方法名相同,方法形参列表不同(类型,参数个数,参数顺序)
	//参数列表:参数列表 == 参数的类型+参数的个数 +参数的顺序
	//方法签名: == 方法名称 +方法参数列表
	
	
	//当一个对象创建的时候,会创建一个引用自身的变量--->this

}
