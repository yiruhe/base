package com.tz.jvm;



public class ClassloadingDemo {



    public void test(){

        //加载:查找并加载二进制数据,并为之创建java.lang.Class对象,这个对象封装了
        //连接:
//            -验证:确保被加载类的正确性
//            -准备:为类的静态变量分配内存,并将其初始化成默认值(实例变量只有在new的时候才会初始化,new的时候实例变量才会分配内存)
//                    final static 的值也发生着这里
//            -解析:把类的符号引用转换为直接引用
//        类的初始化:
//            -为类的静态变量赋予正确的初始值(此时的赋予的值就是用户的值)


        //类的主动使用
//            – 创建类的实例
//            – 访问某个类或接口的静态变量，或者对该静态
//                变量赋值
//            – 调用类的静态方法
//            – 反射（如 Class.forName(“com.Test”)
//）
//            – 初始化一个类的子类,如果父类没有初始化,也会初始化父类
//            – Java虚拟机启动时被标明为启动类的类（Java Test） //main方法

//        所有的java虚拟机实现必须在每个类或者java程序"首次主动使用"时才初始化他们,除了上面的6种
//        都不会对类进行初始化

       /*
            类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内
            ，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构
        */




//
        //!!!!!!!!!!!!!!!!!!!!!!!!!!
//        =>调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导
//        致类的初始化。
//        =>只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以
//         认为是对类或接口的主动使用(for example:

//                子类继承了父类的静态属性,当子类访问父类的静态属性的时候

//
//
//
// )

            //编译时静态常量:不会初始化类(static final在准备阶段就会附上正确的值)

            //不是编译时常量就会执行
            // 因为interface中的数据成员都是final的和static的.所以一般是在编译的时候就初始化好了的.
//                static final int a = 10;  //不会

                //非编译时确定的常量,使用的时候会对类进行初始化
                //static final int b = new Random(10); //会 : 编译时无法确定


        //类的加载是指:
//            -是将类的。class文件的二进制数据读入内存中,将其放在数据区的方法区,然后在堆中创建一个
//             与这个类所对应的java.lang.Class对象,用来封装类在方法区内的数据结构,这个类的创建是由
//             jvm完成,class对象含有访问方法区

//            -类加载最终的产品就是堆中的class对象,class文件封装了类在方法区的数据结构,
//                并向程序员提供了访问方法区的数据结构接口(反射),

//        -两种类加载器
//          1.java自带:
//            -根类加载器(bootStrap):c++实现,程序员无法获取
//            -扩展类加载器(Extension):java实现
//            -系统类加载器(System):java实现

//          2.用户自定义类加载器:
//                java.lang.classLoader的子类


//        1.类的加载
        //  JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载
        //      的过程中遇到了.class文件缺失或存在错误,类加载器必须在程序首次主动使用该类
        //      时才报告错误（LinkageError错误）

        //• 如果这个类一直没有被程序主动使用，那
        //        么类加载器就不会报告错误

        //2.类的连接
           // • 类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据合并
            //      到虚拟机的运行时环境中去。

        //3.类的验证:


        //4.类的准备:
//            在准备阶段,JAVA虚拟机会为类的静态变量分配内存,并设置默认的初始值(由上至下)
                    //列如: sample类 在在准备阶段,将为int类型的静态变量a分配4个字节空间,并赋予默认值0
                //初始化的时候才会赋予用户给定的值

        //5.类的解析:
//            将符号引用替换为直接引用(指针)


        //初始化:
            //赋予用户设定的默认值


        //---------------------------------------------------


//        在准备阶段,java虚拟机为类的静态变量分配内存,并设置默认的初始值.for example:
//
//        class Test{
//          static int a= 1;
//          static long b;

//        }
        //对Test类,在准备阶段,将int类型的静态变量a分配4个字节的内存空间,并赋予默认值0,long分配8个赋予默认值0;

        //-------------------------------------

//        for example:

//              car.run();  //这段代码在类中的二进制文件表示符号引用

        //符号引用有方法的全名,和相关描述组成,在解析阶段,jvm会把符号引用替换为一个指针
        //该指针指向car类的run方法在方法区的内幕才能位置,这个指针就是直接引用



        //静态初始化:


//        class Test{
//            static Object c = new Test();  //1.先赋值
//            static int a;
//            static int b=0; 3.1 //这时候 还是jvm默认赋值的0;
                                    //等前面初始化完毕后 jvm又会把0付给b;

//                Test(){
//                    a++;2.
//                    b++;3.
//                 }

//            public static void main(String[] args){

//                    System.out.println(Test.a); //1
//                    System.out.println(Test.b); //0

//            }
//
//
//        }

        //=====================================================

        //类初始化的时机:(接口和类是不一样的)
        //java虚拟机初始化一个类的时候,要求他所有的类都被初始化,但是这条规则不适用于接口
        //  1.初始化一个类的时候,并不会先去初始化它所实现的接口
        //  2.初始化一个接口时,并不会先初始化它的父接口
//        因此,一个父接口并不会因为它的子接口或者实现类的初始化而初始化,
//          只有当程序首次使用特定接口的静态变量时,才会初始化

        //同一个类加载中,一个类已经初始化了,不会再次初始化
        //子类的使用会导致父类的初始化


        //只有当程序访问的静态变量或静态方法确实在当前类或者接口中定义时,才可以认为是对类或者接口的主动使用



        //==================================================================



       // 调用ClassLoader类的loadClass方法加载 一个类，并不是对类的主动使用，不会导 致类的初始化
        //仅仅加载class文件(二进制数据),不会初始化类



        //加载机制:
        //若一个类加载器收到类加载请求，他首先不会自己尝试去加载这个类，
        // 而是把这个请求委派给父类加载器去完成，每一层类加载器都是如此
        // ，所以所有请求都会传送到顶层的BootStrap ClassLoader,
        // 只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围没找到)，
        // 子加载器才会自己尝试去加载。


        //根类加载器:
        //      该加载器没有父加载器,根类加载的实现依赖于底层操作系统,属于虚拟机实现的一部分,
        //      没有继承java.land.ClassLoad类

        //拓展类加载器:
        //      它的父类加载器为根类加载器,扩展类加载器是纯Java类,是java.land.ClassLoad类的子类

        //系统类加载器:
                //它的父加载器为拓展类加载器,它从环境变量classpath或者系统属性java.class.path指定的目录加载类,
                //纯Java类,是java.land.ClassLoad类的子类

        //加载器之间不是继承关系,是包装关系(子类包装父类加载器)

            //java提供ClassLoader类,用户继承这个抽象类,可以自定义加载器


            //如果某个类可以加载一个类,那么成定义类加载器
            //子类和本身称初始类加载器


            //自定义一个类加载器,没有指定父加载器,那么会使用系统类加载器作为父加载器



            //每个类加载器都有自己的命名空间,命名空间由该加载器以及父加载器的类所组成
            //同一个命名空间,不会出现两个相同的类



            //运行时包:
                    //同一个类加载器加载的属于相同包的类组成了运行时包.决定两个运行时包不仅要看他们的包名是否相等

                    //还要看定义类加载器是否相等.只有属于同一运行时包的类才能相互访问包可见(即默认访问级别)的类和类成员


            //不同类加载器的命名空间
                //1.同一命名空间的类是相互可见的
                //2.子加载器的命名空间包含父加载器的命名空间,因此由子加载器加载的类能看见父加载器加载的类
                //例如:系统类加载器可以看见根类加载器加载的类
                //3.由父加载器加载的类不能看见子加载器加载的类(可以通过反射)
                //如果两个加载器之间没有直接或者间接的父子关系,那么它们各自加载的类相互不可见



            //类的卸载:
                //当一个类被加载,连接和 初始化后,它的生命周期就开始了,
                //当代表这个类的Class对象不再被引用,Class对象就会结束生命周期,这个类在在方法区的数据
                //也会被卸载,从而结束这个类的生命周期,

                //一个类何时结束生命周期,取决于代表他的Class对象何时结束生命周期

                //Java虚拟机自带的类加载器所加载的类,在虚拟机的生命周期中,始终不会被卸载
                //根,扩展,系统,类加载器.Java虚拟机本身会始终引用这些类加载器,这些类加载器会始终引用他们所加载的
                //类的Class对象

                //用户自定义加载的类是可以被卸载的


                //类被加载器加载,在类的加载器的内部实现中,用一个Java集合来存放所加载类的引用
                //另一方面,一个Class对象总是会引用它的类加载器,调用Class对象的getClassLoader()
                //就可以获取它的类加载器,由此可见Class实例与它的类加载器之间为双向关联

                //而一个类的实例总是引用这个类的Class对象,比如getClass(),和他的静态属性class

                //由下至上检查类是否被加载,由上至下尝试加载



    }

}
